-----------------------------------------------------------------------------
$Id: Info.lhs,v 1.5 1997/09/09 16:31:44 simonm Exp $

Generating info files.

(c) 1993-1996 Andy Gill, Simon Marlow
-----------------------------------------------------------------------------

> module Info (genInfoFile) where

> import Version		( version )
> import LALR 			( Lr0Item(..) )
> import GenUtils
> import Set
> import AbsSyn
> import Grammar
> import ProduceCode		( str, interleave, interleave' )

#if __HASKELL1__ >= 3 && ( !defined(__GLASGOW_HASKELL__) || __GLASGOW_HASKELL__ >= 200 )

> import Array
> import List (nub)

#define ASSOC(a,b) (a , b)
#else
#define ASSOC(a,b) (a := b)
#endif

Produce a file of parser information, useful for debugging the parser.

> genInfoFile
>	:: Array Int String
>	-> [Set Lr0Item]
>	-> GrammarInfo
>	-> ActionTable
>	-> GotoTable
>	-> [(Int,String)]
>	-> Array Int (Int,Int)
>	-> String
>	-> String

> genInfoFile env items 
> 	(GrammarInfo prods lookupProdNo lookupProdsOfName nonterms terms eof
>		first_term)
>	 action goto tokens conflictArray filename
> 	= (showHeader
>	. showConflicts
>	. showProductions 
>	. showTerminals 
>	. showNonTerminals 
>	. showStates
>	. showStats
>	) ""
>   where

>   showHeader 
>   	= banner ("Info file generated by Happy Version " ++ 
>		  version ++ " from " ++ filename)

>   showConflicts
>	= str "\n"
>	. foldr (.) id (map showConflictsState (assocs conflictArray))
>	. str "\n"

>   showConflictsState ASSOC(state, (0,0)) = id
>   showConflictsState ASSOC(state, (sr,rr))
>   	= str "state "
>	. shows state
>	. str " contains "
>	. interleave' " and " (
>		(if sr /= 0 
>			then [ shows sr . str " shift/reduce conflicts" ]
>			else []) ++
>		 if rr /= 0
>			then [ shows rr . str " reduce/reduce conflicts" ]
>			else [])
>	. str ".\n"

>   showProductions = 
>	  banner "Grammar"
>	. interleave "\n" (zipWith showProduction prods [ 0 :: Int .. ])
>	. str "\n"
  
>   showProduction (nt, toks, sem) i
> 	= ljuststr 50 (
>	  str "\t"
>	. showName nt
>	. str " -> "
>	. interleave " " (map showName toks))
>	. str "  (" . shows i . str ")"

>   showStates =
>   	  banner "States"
>	. interleave "\n" (zipWith showState 
>		(map setToList items) [ 0 :: Int .. ])

>   showState state n
>   	= str "State ". shows n
>	. str "\n\n"
>	. interleave "\n" (map showItem [ (r,d) | (r,d) <- state, d /= 0 ])
>	. str "\n"
>   	. foldr (.) id (map showAction (assocs (action ! n)))
>	. str "\n"
>   	. foldr (.) id (map showGoto (assocs (goto ! n)))

>   showItem (rule,dot)
>   	= ljuststr 50 (
>	  	  str "\t"
>		. showName nt
>		. str " -> "
>		. interleave " " (map showName beforeDot)
>		. str ". "
>		. interleave " " (map showName afterDot))
>	. str "   (rule " . shows rule . str ")"
>	where
>		(nt, toks, sem) = lookupProdNo rule
>		(beforeDot, afterDot) = splitAt dot toks

>   showAction ASSOC(t, LR'Fail)
>   	= id
>   showAction ASSOC(t, act)
>   	= str "\t"
>	. showJName 15 t
>	. showAction' act
>	. str "\n"

>   showAction' (LR'Shift n)
>   	= str "shift, and enter state "
>	. shows n
>   showAction' LR'Accept
>   	= str "accept"
>   showAction' (LR'Reduce n)
>   	= str "reduce using rule "
>	. shows n
>   showAction' (LR'Multiple as a)
>   	= showAction' a
>	. str "\n"
>	. interleave "\n" 
>		(map (\a -> str "\t\t\t(" . showAction' a . str ")") 
>		 (nub (filter (/= a) as)))

>   showGoto ASSOC(nt, NoGoto)
>   	= id
>   showGoto ASSOC(nt, Goto n)
>   	= str "\t"
>	. showJName 15 nt
>	. str "goto state "
>	. shows n
>	. str "\n"

>   showTerminals
>   	= banner "Terminals"
>	. interleave "\n" (map showTerminal tokens)
>	. str "\n"

>   showTerminal (t,s)
>   	= str "\t"
>	. showJName 15 t
>	. str "{ " . str s . str " }"

>   showNonTerminals
>   	= banner "Non-terminals"
>	. interleave "\n" (map showNonTerminal nonterms)
>	. str "\n"

>   showNonTerminal nt
>   	= str "\t"
>	. showJName 15 nt
>	. (if (length nt_rules == 1)
>		then str "rule  "
>		else str "rules ")
>	. foldr1 (\a b -> a . str ", " . b) nt_rules
>	where nt_rules = map shows (lookupProdsOfName nt)

>   showStats 
>	= banner "Grammar Totals"
>	. str   "Number of rules: " . shows (length prods)
>	. str "\nNumber of terminals: " . shows (length tokens)
>	. str "\nNumber of non-terminals: " . shows (length nonterms)
>	. str "\nNumber of states: " . shows (length items)
>	. str "\n"

>   nameOf n    = env ! n
>   showName    = str . nameOf
>   showJName j = str . ljustify j . nameOf

> ljuststr n s = str (ljustify n (s ""))

> banner s 
> 	= str "-----------------------------------------------------------------------------\n"
>	. str s
>	. str "\n-----------------------------------------------------------------------------\n"

